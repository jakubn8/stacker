This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.


# Project Name: Stacker (Whop Native B2B App)

1. Project Overview
Stacker is a B2B application for the Whop.com marketplace. It helps Community Owners increase revenue by offering intelligent post-purchase upsells and a persistent storefront.

The Core Value: We charge a 5% Transaction Fee on all revenue generated by our app (Upsells & Storefront buys). We use an Auto-Charge model (Vaulted Card) to make billing seamless for the owner.

2. Tech Stack
Framework: Next.js 14 (App Router).

Database: Firebase Firestore (NoSQL).

UI Library: @whop/frosted-ui.

SDK: @whop/sdk.

3. Database Schema (Firestore)
Collection: companies (Doc ID: company_id)
Stores the configuration and billing status for each community owner.

JSON

{
  "company_id": "biz_123",
  "payment_method_id": "pm_xyz", // The Vaulted Card ID for our 5% fee
  "billing_status": "active", // or 'unpaid_lockout' if charge fails
  "total_revenue_generated": 150000, // In cents ($1,500.00)
  "config": {
    "is_active": true,
    // The Logic Flow
    "trigger_product_id": "prod_123",
    "upsell_product_id": "prod_456",
    "downsell_product_id": "prod_789",
    // The Live Editor Settings
    "offer_page_settings": {
       "headline": "Wait! Your order isn't complete...",
       "subheadline": "Add this exclusive offer...",
       "button_text": "Yes, Upgrade My Order",
       "bullet_points": ["Benefit 1", "Benefit 2"],
       "show_social_proof": true,
       "review_text": "Saved my account!",
       "review_author": "@CryptoKing",
       "review_stars": 5
    }
  },
  // The Storefront "Metadata Layer" (Overrides)
  "product_overrides": {
     "prod_456": {
        "custom_title": "VIP Protocol",
        "custom_image_url": "https://...",
        "show_discount": true,
        "original_price": 9900 // $99.00
     }
  }
}
Collection: fees
Tracks the money the owner owes us.

JSON

{
  "company_id": "biz_123",
  "amount_cents": 500, // $5.00 (Our 5% cut of a $100 sale)
  "source_transaction_id": "pay_abc", // The Whop Payment ID of the upsell
  "status": "unbilled", // changes to 'paid' after weekly cron runs
  "created_at": "timestamp"
}
4. The "Vault & Charge" Billing Architecture
A. Onboarding (The "Vault Gate")
On the Dashboard (/dashboard/[id]), we run a check:

Check: Does companies/{id}.payment_method_id exist?

If NO: Render a "Connect Billing" Overlay.

Content: "Connect a payment method to activate Stacker."

Action: Redirect to whop.checkoutLinks.create({ mode: 'setup' }).

On Return: Save the payment_method_id to Firestore.

If YES: Render the full Dashboard.

B. The Weekly Auto-Charge (Cron)
Frequency: Every Friday at 17:00 UTC (Vercel Cron). Logic:

Loop through all companies.

Sum all unbilled fees.

If Total > $10.00:

Call whop.payments.create({ amount: total, payment_method: saved_id, off_session: true }).

Success: Mark fees as paid. Send email receipt.

Failure: Set billing_status = 'unpaid_lockout'. Disable app features.

5. Required Whop Permissions
We must request these in the Developer Dashboard:

payments.write (To charge users for upsells AND charge owners for fees).

memberships.read (For the Inventory Check - "Do they already own this?").

products.read (To populate the dashboard dropdowns).

webhook_receive:payments (To listen for sales and calculate our 5% fee).

6. App Architecture & Views
View A: The "Live Editor" (/dashboard/[id]/editor)
Split Screen: Left side is a live preview of the Post-Purchase Modal. Right side is the form.

Logic: Updates the offer_page_settings in Firestore.

View B: The "Intercept" (/intercept)
Logic:

Check config.is_active AND billing_status !== 'unpaid_lockout'.

Check Inventory: Does user own the upsell product?

If valid, show the Modal.

On "Buy" click: Call whop.payments.create() -> Log fee to fees collection.

View C: The "Storefront" (/experience)
Logic:

Fetch product list from Whop SDK.

Merge with product_overrides from Firestore (custom images/titles).

Render Grid.

6. Reference Links
Whop Webhooks: https://docs.whop.com/developer/guides/webhooks

Whop Payments API: https://www.google.com/search?q=https://docs.whop.com/whop-apps/b2b-apps%23accept-payments-in-your-app